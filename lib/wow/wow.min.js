(function (global, factory) {
    if (typeof define === "function" && define.amd) {
      // AMD (Asynchronous Module Definition)
      define(["module", "exports"], factory);
    } else if (typeof exports !== "undefined") {
      // CommonJS (Node-style)
      factory(module, exports);
    } else {
      // Global (browser)
      var mod = { exports: {} };
      factory(mod, mod.exports);
      global.WOW = mod.exports;
    }
  })(this, function (module, exports) {
    "use strict";
  
    // Utility Functions
    function isMobile(userAgent) {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);
    }
  
    function triggerEvent(name, bubbles = false, cancelable = false, detail = null) {
      let event;
      if (typeof document.createEvent === "function") {
        event = document.createEvent("CustomEvent");
        event.initCustomEvent(name, bubbles, cancelable, detail);
      } else if (document.createEventObject) {
        event = document.createEventObject();
        event.eventType = name;
      } else {
        event = { eventName: name };
      }
      return event;
    }
  
    function dispatchEvent(element, event) {
      if (element.dispatchEvent) {
        element.dispatchEvent(event);
      } else if (event in element) {
        element[event]();
      } else if (`on${event}` in element) {
        element[`on${event}`]();
      }
    }
  
    function addEvent(element, type, callback) {
      if (element.addEventListener) {
        element.addEventListener(type, callback, false);
      } else if (element.attachEvent) {
        element.attachEvent("on" + type, callback);
      } else {
        element[type] = callback;
      }
    }
  
    function removeEvent(element, type, callback) {
      if (element.removeEventListener) {
        element.removeEventListener(type, callback, false);
      } else if (element.detachEvent) {
        element.detachEvent("on" + type, callback);
      } else {
        delete element[type];
      }
    }
  
    function getViewportHeight() {
      return window.innerHeight || document.documentElement.clientHeight;
    }
  
    // Polyfill: WeakMap for caching
    const AnimationCache = window.WeakMap || function () {
      function Cache() {
        this.keys = [];
        this.values = [];
      }
      Cache.prototype.get = function (key) {
        const index = this.keys.indexOf(key);
        return index !== -1 ? this.values[index] : undefined;
      };
      Cache.prototype.set = function (key, value) {
        const index = this.keys.indexOf(key);
        if (index !== -1) {
          this.values[index] = value;
        } else {
          this.keys.push(key);
          this.values.push(value);
        }
      };
      return Cache;
    }();
  
    // WOW Class
    class WOW {
      constructor(options = {}) {
        this.defaults = {
          boxClass: "wow",
          animateClass: "animated",
          offset: 0,
          mobile: true,
          live: true,
          callback: null,
          scrollContainer: null,
          resetAnimation: true
        };
        this.config = Object.assign({}, this.defaults, options);
        this.animationNameCache = new AnimationCache();
        this.scrollHandler = this.scrollHandler.bind(this);
        this.scrollCallback = this.scrollCallback.bind(this);
        this.scrolled = true;
        this.wowEvent = triggerEvent(this.config.boxClass);
      }
  
      init() {
        this.element = document.documentElement;
        this.boxes = Array.prototype.slice.call(
          this.element.querySelectorAll(`.${this.config.boxClass}`)
        );
        this.all = this.boxes.slice(0);
  
        if (!this.boxes.length) return;
  
        if (!this.disabled()) {
          this.boxes.forEach(box => this.applyStyle(box, true));
          addEvent(this.config.scrollContainer || window, "scroll", this.scrollHandler);
          addEvent(window, "resize", this.scrollHandler);
          this.interval = setInterval(this.scrollCallback, 50);
        }
  
        if (this.config.live) {
          const observer = new MutationObserver(records => {
            records.forEach(record => {
              Array.prototype.slice.call(record.addedNodes).forEach(node => this.sync(node));
            });
          });
          observer.observe(document.body, { childList: true, subtree: true });
        }
      }
  
      disabled() {
        return !this.config.mobile && isMobile(navigator.userAgent);
      }
  
      scrollHandler() {
        this.scrolled = true;
      }
  
      scrollCallback() {
        if (!this.scrolled) return;
        this.scrolled = false;
  
        this.boxes = this.boxes.filter(box => {
          if (this.isVisible(box)) {
            this.show(box);
            return false;
          }
          return true;
        });
  
        if (!this.boxes.length && !this.config.live) {
          this.stop();
        }
      }
  
      stop() {
        clearInterval(this.interval);
        removeEvent(this.config.scrollContainer || window, "scroll", this.scrollHandler);
        removeEvent(window, "resize", this.scrollHandler);
      }
  
      show(box) {
        this.applyStyle(box);
        box.classList.add(this.config.animateClass);
  
        if (this.config.callback) this.config.callback(box);
  
        dispatchEvent(box, this.wowEvent);
  
        if (this.config.resetAnimation) {
          ["animationend", "webkitAnimationEnd", "oanimationend", "MSAnimationEnd"].forEach(evt =>
            addEvent(box, evt, this.resetAnimation.bind(this))
          );
        }
      }
  
      applyStyle(box, hidden = false) {
        const duration = box.getAttribute("data-wow-duration");
        const delay = box.getAttribute("data-wow-delay");
        const iteration = box.getAttribute("data-wow-iteration");
  
        this.animate(() => {
          box.style.visibility = hidden ? "hidden" : "visible";
          if (duration) box.style.animationDuration = duration;
          if (delay) box.style.animationDelay = delay;
          if (iteration) box.style.animationIterationCount = iteration;
          box.style.animationName = hidden ? "none" : this.getCachedAnimationName(box);
        });
      }
  
      getCachedAnimationName(box) {
        if (!this.animationNameCache.get(box)) {
          this.animationNameCache.set(box, this.getAnimationName(box));
        }
        return this.animationNameCache.get(box);
      }
  
      getAnimationName(box) {
        const style = getComputedStyle(box);
        return style.getPropertyValue("animation-name") || "";
      }
  
      isVisible(box) {
        const offset = parseInt(box.getAttribute("data-wow-offset") || this.config.offset, 10);
        const scrollTop = window.pageYOffset;
        const viewBottom = scrollTop + getViewportHeight() - offset;
        const boxTop = this.offsetTop(box);
        const boxBottom = boxTop + box.clientHeight;
        return viewBottom >= boxTop && boxBottom >= scrollTop;
      }
  
      offsetTop(element) {
        let top = element.offsetTop;
        while ((element = element.offsetParent)) {
          top += element.offsetTop;
        }
        return top;
      }
  
      animate(callback) {
        if ("requestAnimationFrame" in window) {
          requestAnimationFrame(callback);
        } else {
          callback();
        }
      }
  
      sync(node) {
        if (!node || node.nodeType !== 1) return;
  
        const elements = node.querySelectorAll(`.${this.config.boxClass}`);
        elements.forEach(el => {
          if (!this.all.includes(el)) {
            this.boxes.push(el);
            this.all.push(el);
            this.applyStyle(el, true);
          }
        });
  
        this.scrolled = true;
      }
  
      resetAnimation(event) {
        if (event.type.toLowerCase().includes("animationend")) {
          event.target.classList.remove(this.config.animateClass);
        }
      }
    }
  
    // Export the class
    exports.default = WOW;
    module.exports = exports.default;
  });
  